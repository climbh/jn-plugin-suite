# simple-uploader 插件改造文档

## 改造需求

为 simple-uploader 插件添加 `checkChunkUploaded` 回调功能，实现以下目标：

1. 当配置 `testChunks: false` 时，支持通过 `checkChunkUploaded` 回调函数跳过已存在的分片
2. 确保所有分片被跳过时，仍能正确触发 `fileSuccess`、`fileProgress` 等事件
3. 确保 `testChunks` 配置能正确控制两种检查模式的执行

## 两种分片检查模式对比

| 配置 | testChunks | 使用回调 | 检查时机 | 适用场景 |
|------|------------|----------|----------|----------|
| 模式1 | `true` | `checkChunkUploadedByResponse` | 分片上传完成后 | 服务器返回响应后判断分片状态 |
| 模式2 | `false` | `checkChunkUploaded` | 分片发送前 | 客户端预先知道分片是否需要跳过 |

## 核心问题分析

### 原始上传流程

1. `uploadNextChunk()` 找到 `PENDING` 状态的分片
2. 调用 `chunk.send()` 发送网络请求
3. 网络请求完成后触发 `doneHandler`
4. `doneHandler` 调用 `processResponse` 处理响应
5. 根据处理结果设置 `processedState` 并触发事件
6. `_event()` 调用 `file._chunkEvent()` 处理文件级事件
7. `file._chunkEvent()` 中的 `SUCCESS` 分支调用 `_updateUploadedChunks()`
8. `_updateUploadedChunks()` 继续下一分片或触发文件完成事件

### 发现的问题

1. **配置冲突**：原代码没有正确处理 `testChunks` 配置，导致两种模式会同时执行
2. **事件缺失**：跳过的分片无法触发完整的事件链，导致 `fileSuccess` 等事件不触发
3. **时机错误**：需要在发送前就能跳过分片，而不是响应后

## 修改方案详解

### 1. uploader.js 修改

#### 1.1 添加新配置项

```javascript
Uploader.defaults = {
  // ... 其他配置
  checkChunkUploaded: null, // 新增：当testChunks为false时用于检查分片是否需要跳过
  // ... 其他配置
}
```

#### 1.2 修改 uploadNextChunk 方法

关键改动：添加 `testChunks` 判断，确保两种模式不会冲突

```javascript
uploadNextChunk: function (preventEvents) {
  var found = false
  var pendingStatus = Chunk.STATUS.PENDING
  // 关键修改：只有testChunks为true时才使用checkChunkUploadedByResponse
  var checkChunkUploadedByResponse = this.opts.testChunks ? this.opts.checkChunkUploadedByResponse : null
  
  // ... 其余逻辑保持不变
}
```

### 2. chunk.js 核心修改

#### 2.1 修改 `send()` 方法

在实际网络请求之前添加跳过逻辑：

```javascript
async send() {
  // ... 预处理和读取逻辑 ...
  
  // 新增：当testChunks为false时，检查checkChunkUploaded回调
  if (!this.uploader.opts.testChunks && this.uploader.opts.checkChunkUploaded && !this.tested) {
    var shouldSkip = this.uploader.opts.checkChunkUploaded.call(this.uploader, this)
    if (shouldSkip) {
      // 跳过这个分片，直接标记为成功
      this._markAsSkipped()
      return
    }
  }
  
  // ... 原有的网络请求逻辑 ...
}
```

#### 2.2 添加 `_markAsSkipped()` 方法

完整模拟真实上传流程，确保事件链正确触发：

```javascript
_markAsSkipped() {
  // 创建一个模拟的xhr对象表示成功状态
  this.xhr = {
    status: 200,
    responseText: JSON.stringify({skipped: true, success: true}),
    readyState: 4
  }
  
  this.tested = true
  this.loaded = this.endByte - this.startByte // 设置为分片完整大小
  this.total = this.endByte - this.startByte
  this.processingResponse = true // 先设置为处理中
  
  var self = this
  var response = JSON.stringify({skipped: true, success: true})
  
  // 使用setTimeout模拟异步网络响应
  setTimeout(function() {
    // 模拟完整的doneHandler流程
    self.processingResponse = true
    self.uploader.opts.processResponse(response, function(err, res) {
      self.processingResponse = false
      if (!self.xhr) {
        return
      }
      self.processedState = {
        err: err,
        res: res || response
      }
      
      var status = self.status()
      if (status === STATUS.SUCCESS || status === STATUS.ERROR) {
        // 触发事件，这会调用file._chunkEvent
        self._event(status, res || response)
        if (status === STATUS.ERROR) {
          self.uploader.uploadNextChunk()
        }
      } else {
        // 重试逻辑
        self._event(STATUS.RETRY, res || response)
        self.pendingRetry = true
        self.abort()
        self.retries++
        var retryInterval = self.uploader.opts.chunkRetryInterval
        if (retryInterval) {
          setTimeout(function() {
            self.send()
          }, retryInterval)
        } else {
          self.send()
        }
      }
    }, self.file, self)
  }, 0)
}
```

### 3. file.js 关键修改

#### 3.1 修改 _updateUploadedChunks 方法

添加 `testChunks` 判断，确保两种模式互不干扰：

```javascript
_updateUploadedChunks: function (message, chunk) {
  var checkChunkUploadedByResponse = this.uploader.opts.checkChunkUploadedByResponse
  
  // 关键修改：只有当testChunks为true时才执行checkChunkUploadedByResponse逻辑
  if (this.uploader.opts.testChunks && checkChunkUploadedByResponse) {
    // 原有的checkChunkUploadedByResponse处理逻辑
    var xhr = chunk.xhr
    utils.each(this.chunks, function (_chunk) {
      if (!_chunk.tested) {
        var uploaded = checkChunkUploadedByResponse.call(this, _chunk, message)
        if (_chunk === chunk && !uploaded) {
          _chunk.xhr = null
        }
        if (uploaded) {
          _chunk.xhr = xhr
        }
        _chunk.tested = true
      }
    }, this)
    if (!this._firstResponse) {
      this._firstResponse = true
      this.uploader.upload(true)
    } else {
      this.uploader.uploadNextChunk()
    }
  } else {
    // testChunks为false或者没有checkChunkUploadedByResponse时的正常流程
    this.uploader.uploadNextChunk()
  }
}
```

#### 3.2 修改 bootstrap 方法

```javascript
bootstrap: function () {
  // ... 其他逻辑 ...
  this._firstResponse = false // 确保重置第一次响应标记
  // ... 其他逻辑 ...
}
```

## 关键设计思路

### 1. 配置互斥性

通过 `testChunks` 配置来控制使用哪种检查模式：

- `testChunks: true` → 使用 `checkChunkUploadedByResponse`
- `testChunks: false` → 使用 `checkChunkUploaded`

### 2. 时机控制

- **checkChunkUploaded**：在 `chunk.send()` 方法开始时检查，发送前跳过
- **checkChunkUploadedByResponse**：在响应处理时检查，响应后判断

### 3. 完整事件流

`_markAsSkipped()` 必须完整模拟真实上传的每个步骤：

1. 设置xhr对象和分片状态
2. 调用processResponse触发用户回调
3. 设置processedState保存结果
4. 触发SUCCESS事件调用文件级事件处理
5. 异步执行确保事件顺序正确

## 使用方式

### 模式1：testChunks = true（响应后检查）

```javascript
var uploader = new Uploader({
  testChunks: true,
  checkChunkUploadedByResponse: function(chunk, message) {
    // 根据服务器响应判断分片是否已存在
    var response = JSON.parse(message);
    return response.chunkExists === true;
  }
});
```

### 模式2：testChunks = false（发送前检查）

```javascript
var uploader = new Uploader({
  testChunks: false,
  checkChunkUploaded: function(chunk) {
    // 发送前检查分片是否需要跳过
    var params = chunk.getParams();
    var chunkIdentifier = params.identifier + '-' + params.chunkNumber;
    var uploadedChunks = JSON.parse(localStorage.getItem('uploadedChunks') || '{}');
    return uploadedChunks[chunkIdentifier] === true;
  },
  
  fileSuccess: function(rootFile, file, response) {
    console.log('文件上传成功:', file.name);
  }
});
```

## 配置冲突处理

现在即使你同时配置了两个回调函数，也只会根据 `testChunks` 的值执行对应的逻辑：

```javascript
var uploader = new Uploader({
  testChunks: false, // 这个决定使用哪种模式
  
  checkChunkUploaded: function(chunk) {
    // testChunks=false时，这个会执行
    return true;
  },
  
  checkChunkUploadedByResponse: function(chunk, message) {
    // testChunks=false时，这个不会执行
    return false;
  }
});
```

## 事件触发保证

无论使用哪种模式，都能确保：

1. **分片级事件**：跳过的分片会触发 `STATUS.SUCCESS` 事件
2. **文件级事件**：`fileProgress` 正常更新进度
3. **完成事件**：所有分片跳过时，`fileSuccess` 和 `complete` 事件正常触发
4. **API一致性**：对外行为完全一致

## 调试检查清单

遇到问题时检查：

1. **配置检查**
   - `testChunks` 是否设置正确
   - 对应的回调函数是否定义
   - 回调函数返回值是否正确（true=跳过，false=上传）

2. **流程检查**
   - `processResponse` 是否正确处理跳过分片的响应
   - 浏览器控制台是否有错误
   - 网络面板中是否有预期的请求行为

3. **事件检查**
   - `fileProgress` 事件是否正常触发
   - `fileSuccess` 事件是否在所有分片完成后触发

## 总结

这次改造的核心成果：

1. **解决配置冲突**：通过 `testChunks` 正确控制两种检查模式的执行
2. **完整事件支持**：跳过分片时完整模拟上传流程，确保所有事件正确触发
3. **时机控制精准**：在正确的时机进行分片检查，避免不必要的网络请求
4. **向后兼容**：不破坏原有API，现有使用 `checkChunkUploadedByResponse` 的代码仍然正常工作

改造后的插件既支持传统的响应后检查模式，也支持新的发送前检查模式，两种模式通过 `testChunks` 配置进行切换，互不干扰。

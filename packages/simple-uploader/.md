# simple-uploader 插件改造文档

## 改造需求

为 simple-uploader 插件添加 `checkChunkUploaded` 回调功能，实现以下目标：

1. 当配置 `testChunks: false` 时，支持通过 `checkChunkUploaded` 回调函数跳过已存在的分片
2. 确保所有分片被跳过时，仍能正确触发 `fileSuccess`、`fileProgress` 等事件

## 核心问题分析

### 原始上传流程

1. `uploadNextChunk()` 找到 `PENDING` 状态的分片
2. 调用 `chunk.send()` 发送网络请求
3. 网络请求完成后触发 `doneHandler`
4. `doneHandler` 调用 `processResponse` 处理响应
5. 根据处理结果设置 `processedState` 并触发事件
6. `_event()` 调用 `file._chunkEvent()` 处理文件级事件
7. `file._chunkEvent()` 中的 `SUCCESS` 分支调用 `_updateUploadedChunks()`
8. `_updateUploadedChunks()` 继续下一分片或触发文件完成事件

### 问题所在

- `checkChunkUploadedByResponse` 只在响应后工作，需要在发送前就能跳过分片
- 跳过的分片必须完整模拟真实上传流程，否则无法触发正确的事件链

## 修改方案

### 1. uploader.js 修改

在 `Uploader.defaults` 中添加新配置项：

```javascript
Uploader.defaults = {
  // ... 其他配置
  checkChunkUploaded: null, // 新增：当testChunks为false时用于检查分片是否需要跳过
  // ... 其他配置
}
```

### 2. chunk.js 核心修改

#### 2.1 修改 `send()` 方法

在 `send()` 方法中，在实际网络请求之前添加跳过逻辑：

```javascript
async send() {
  // ... 预处理和读取逻辑 ...
  
  // 新增：当testChunks为false时，检查checkChunkUploaded回调
  if (!this.uploader.opts.testChunks && this.uploader.opts.checkChunkUploaded && !this.tested) {
    var shouldSkip = this.uploader.opts.checkChunkUploaded.call(this.uploader, this)
    if (shouldSkip) {
      // 跳过这个分片，直接标记为成功
      this._markAsSkipped()
      return
    }
  }
  
  // ... 原有的网络请求逻辑 ...
}
```

#### 2.2 添加 `_markAsSkipped()` 方法

关键在于完整模拟真实上传流程：

```javascript
_markAsSkipped() {
  // 创建一个模拟的xhr对象表示成功状态
  this.xhr = {
    status: 200,
    responseText: JSON.stringify({skipped: true, success: true}),
    readyState: 4
  }
  
  this.tested = true
  this.loaded = this.endByte - this.startByte // 设置为分片完整大小
  this.total = this.endByte - this.startByte
  this.processingResponse = true // 先设置为处理中
  
  var self = this
  var response = JSON.stringify({skipped: true, success: true})
  
  // 使用setTimeout模拟异步网络响应
  setTimeout(function() {
    // 模拟完整的doneHandler流程
    self.processingResponse = true
    self.uploader.opts.processResponse(response, function(err, res) {
      self.processingResponse = false
      if (!self.xhr) {
        return
      }
      self.processedState = {
        err: err,
        res: res || response
      }
      
      var status = self.status()
      if (status === STATUS.SUCCESS || status === STATUS.ERROR) {
        // 触发事件，这会调用file._chunkEvent
        self._event(status, res || response)
        if (status === STATUS.ERROR) {
          self.uploader.uploadNextChunk()
        }
      } else {
        // 重试逻辑
        self._event(STATUS.RETRY, res || response)
        self.pendingRetry = true
        self.abort()
        self.retries++
        var retryInterval = self.uploader.opts.chunkRetryInterval
        if (retryInterval) {
          setTimeout(function() {
            self.send()
          }, retryInterval)
        } else {
          self.send()
        }
      }
    }, self.file, self)
  }, 0)
}
```

### 3. file.js 小幅修改

只需要在 `bootstrap()` 方法中重置 `_firstResponse`：

```javascript
bootstrap: function () {
  // ... 其他逻辑 ...
  this._firstResponse = false // 确保重置第一次响应标记
  // ... 其他逻辑 ...
}
```

## 关键设计思路

### 1. 在正确时机检查

- 在 `chunk.send()` 方法中，在实际网络请求发送之前进行检查
- 避免了在 `uploadNextChunk()` 中做复杂的状态判断

### 2. 完整模拟上传流程

`_markAsSkipped()` 方法必须完整模拟真实上传的每个步骤：

1. **设置xhr对象**：模拟成功响应状态
2. **设置分片状态**：loaded、total、tested 等
3. **调用processResponse**：这是关键，触发用户自定义的响应处理逻辑
4. **设置processedState**：保存处理结果
5. **触发SUCCESS事件**：调用 `_event()` 触发文件级事件处理

### 3. 异步执行

使用 `setTimeout(fn, 0)` 模拟异步网络请求，确保事件触发顺序正确。

## 使用方式

```javascript
var uploader = new Uploader({
  target: '/upload',
  testChunks: false, // 关键：必须设置为false
  
  checkChunkUploaded: function(chunk) {
    var params = chunk.getParams();
    var chunkIdentifier = params.identifier + '-' + params.chunkNumber;
    
    // 检查分片是否已存在的逻辑
    // 返回true表示跳过该分片，false表示需要上传
    var uploadedChunks = JSON.parse(localStorage.getItem('uploadedChunks') || '{}');
    return uploadedChunks[chunkIdentifier] === true;
  },
  
  fileSuccess: function(rootFile, file, response) {
    console.log('文件上传成功:', file.name);
  },
  
  fileProgress: function(rootFile, file, chunk) {
    console.log('上传进度:', Math.floor(file.progress() * 100) + '%');
  }
});
```

## 事件触发保证

修改后的流程确保：

1. **分片级事件**：跳过的分片仍会触发 `STATUS.SUCCESS` 事件
2. **文件级事件**：`fileProgress` 正常触发，显示正确进度
3. **完成事件**：所有分片跳过时，`fileSuccess` 和 `complete` 事件正常触发
4. **API一致性**：无论分片是真实上传还是跳过，对外API行为完全一致

## 调试要点

如果遇到问题，检查以下几点：

1. `testChunks` 必须设置为 `false`
2. `checkChunkUploaded` 回调函数的返回值（true=跳过，false=上传）
3. `processResponse` 方法是否正确处理跳过分片的响应
4. 浏览器控制台是否有相关错误信息

## 总结

这次改造的核心在于理解 simple-uploader 的完整上传流程，并在跳过分片时完整模拟这个流程。通过在 `chunk.send()` 方法中添加检查逻辑，并用 `_markAsSkipped()` 方法完整模拟网络请求的处理过程，成功实现了在 `testChunks: false` 时也能跳过已存在分片的功能，同时保证了所有相关事件的正确触发。
